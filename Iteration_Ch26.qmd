---
title: "Chapter 26: Iteration"
subtitle: "Introduction to Data Science"
author: "MATH 265"
format: 
  html:
      theme: materia
      number-sections: true
      number-depth: 2
editor: visual
toc: true
execute: 
  warning: false
  eval: true #comment this line to see all output
---

```{r}
#| label: setup
#| include: false
#| eval: true
library(tidyverse)
library(ggthemes)
library(palmerpenguins)
chiflights2020 <- read_csv("https://people.kzoo.edu/enordmoe/math265/data/chiflight2020.csv")
```

# Outline

-   Modifying multiple columns
    -   Movie data
-   Applying functions `rowwise()`
    -   Gradebook
-   Reading multiple files and combining results
    -   Gapminder Files

## Introduction to Iteration

-   Functions save time and space by avoiding repeatedly typing the same code.

-   R Iteration saves by

    -   Applying the same function to multiple columns

    -   Applying the same multiple functions to multiple columns

    -   Expediting variable selection using `across()`

    -   Allowing functions to include iteration

    -   Applying the same procedures to multiple files

## Is it worth learning about iteration to save time?

![](https://imgs.xkcd.com/comics/is_it_worth_the_time_2x.png)

# Modifying multiple Columns

### Palmer Penguins data

Penguin measurements for several species on multiple islands over multiple years:

```{r}
library(palmerpenguins)
glimpse(penguins)
```

## Compute means of all numeric variables

```{r}
penguins |> summarize(
  mean_bill_length = mean(bill_length_mm),
  mean_bill_depth = mean(bill_depth_mm),
  mean_flipper_length = mean(flipper_length_mm),
  mean_bodymass = mean(body_mass_g)
)
```

Oops, we need to deal with missing values:

```{r}
penguins |> summarize(
  mean_bill_length = mean(bill_length_mm, na.rm = TRUE),
  mean_bill_depth = mean(bill_depth_mm, na.rm = TRUE),
  mean_flipper_length = mean(flipper_length_mm, na.rm = TRUE),
  mean_bodymass = mean(body_mass_g, na.rm = TRUE)
)
```

## Using `across()`

Let's make this more efficient using `across()` which allows us to apply the same function to multiple columns:

```{r}
penguins |> summarize(
  across(bill_length_mm:body_mass_g, mean, na.rm = TRUE)
)
```

But this has been deprecated so let's adopt the use of anonymous functions now recommended:

```{r}
penguins |> summarize(
  across(bill_length_mm:body_mass_g, \(x) mean(x, na.rm = TRUE))
)
```

Note that the syntax `\(x) mean(x, na.rm = TRUE)` allows us to implicitly declare the function with required options.

## Using helper functions to specify sets of variables

Rather than list all the variables or rely on their being in consecutive order, we can use `where()` combined with appropriate `is.xxx()` functions as shown below:

```{r}
# all the numeric variables
penguins |> summarize(
  across(where(is.numeric), \(x) mean(x, na.rm = TRUE))
)

```

# Applying Multiple Functions

We can apply a list of functions to multiple variables by combining `across()` with `list()` and use anonymous functions where needed to pass other arguments.

```{r}
penguins |> summarize(
  across(where(is.numeric), list(
    mean = \(x) mean(x, na.rm = TRUE),
    median = \(x) median(x, na.rm = TRUE),
    nmiss = \(x) sum(is.na(x))
  )
  )
)
```

We can improve upon that a bit by explicitly setting the naming pattern for the created summary variables using `{.fn}` and `{.col}` in "glue specifications":

```{r}
penguins |> summarize(
  across(where(is.numeric), list(
    mean = \(x) mean(x, na.rm = TRUE),
    median = \(x) median(x, na.rm = TRUE),
    nmiss = \(x) sum(is.na(x))
  ),
   .names = "{.fn}_{.col}"
  )
)
```

### Using `across()` in functions

As shown in R4DS, we can create a function that uses `across()` and `list()` to define the output and then apply it to a data set. Note that the function `expand_dates()` takes the entire data frame as a function:

```{r}
# this function creates year, month, day variables from a date object
expand_dates <- function(df) {
  df |> 
    mutate(
      across(where(is.Date), list(year = year, month = month, day = mday))
    )
}
# Demonstrate by creating a small tibble()
df_date <- tibble(
  name = c("Amy", "Bob"),
  date = ymd(c("2009-08-03", "2010-01-16"))
)

# Apply directly to a dataset using the pipe
df_date |> 
  expand_dates()
```

## Applying using groups

Note that all the procedures above can be applied groupwise after using `group_by` as shown in the chunk below for the penguin data:

```{r}
penguins |>
  group_by(island) |>
  summarize(
    across(where(is.numeric), list(
      mean = \(x) mean(x, na.rm = TRUE),
      median = \(x) median(x, na.rm = TRUE),
      nmiss = \(x) sum(is.na(x))
    ),
    .names = "{.fn}_{.col}"
    )
  )
```

::: callout-note
Note that we get a seprate set of statistics for each island. If we wished, we could use `pivot_longer()` to rearrange the output.
:::

# Rowwise operations

Often, we would like to carry out mutate operations involving multiple variables rowwise across columns rather than summarizing across rows as we have done so far. We have seen a few special cases of this like the `pmin()` and `pmax()` function but here is a more general approach. See [here](https://dplyr.tidyverse.org/articles/rowwise.html) for details

One example is carrying out calculations on a gradebook data frame. Here's a constructed sample data frame with a couple kinds of assignments:

```{r}
set.seed(123)  # for reproducibility
num_students <- 20
num_quizzes <-5
num_homeworks <- 7

grades <- data.frame(
  student = paste0("Student", 1:num_students),
  quiz_1 = sample(0:15, num_students, replace = TRUE),
  quiz_2 = sample(0:15, num_students, replace = TRUE),
  quiz_3 = sample(0:15, num_students, replace = TRUE),
  quiz_4 = sample(0:15, num_students, replace = TRUE),
  quiz_5 = sample(0:15, num_students, replace = TRUE),
  homework_1 = sample(0:10, num_students, replace = TRUE),
  homework_2 = sample(0:10, num_students, replace = TRUE),
  homework_3 = sample(0:10, num_students, replace = TRUE),
  homework_4 = sample(0:10, num_students, replace = TRUE),
  homework_5 = sample(0:10, num_students, replace = TRUE),
  homework_6 = sample(0:10, num_students, replace = TRUE),
  homework_7 = sample(0:10, num_students, replace = TRUE)
)

glimpse(grades)
```

Now calculate quiz and homework scores that are averages for each student after dropping the lowest (or two lowest):

```{r}
# Carry out the calculations rowwise and save the results
grades_calc <- grades |>
  rowwise() |>
  mutate(
    quiz_score = mean(sort(c_across(starts_with("quiz_")))[-1]),
    homework_score = mean(sort(c_across(starts_with("homework_")))[-c(1, 2)])
  ) |>
  # The following is just to make it easy to find the scores
  relocate(quiz_score, homework_score, .after = student)

# View the results
grades_calc
```

::: callout-tip
Note that the use of `c_across()` is necessary to make use of tidy select semantics such as `starts_with()`, etc.
:::


We use `sort()` rather than `arrange()` because we are sorting a vector rather than a data frame. The indexing with brackets allows us to drop the one or two lowest as needed after sorting.

# Reading multiple files and combining results

Chapter 26 of R4DS also discusses methods for working with multiple files. In some cases, we merge multiple files first while in others we combine results after working with the files separately.

The gapminder files referenced in this section are in the `gapminder` subfolder of your `data` folder in the `inclass265` repository so you can practice using the commands there.

First, obtain the paths of the files of interest using the system-specific function `list.files()`:

```{r}
paths <- list.files("data/gapminder", pattern = "[.]xlsx$", full.names = TRUE)
paths
```

To facilitate our work on this set, read all the excel spread sheets (with same format) into one list of objects. But that's really too much typing!

```{r}
#| eval: false
files <- list(
  readxl::read_excel("data/gapminder/1952.xlsx"),
  readxl::read_excel("data/gapminder/1957.xlsx"),
  readxl::read_excel("data/gapminder/1962.xlsx"),
  readxl::read_excel("data/gapminder/1967.xlsx"),
  ...
  readxl::read_excel("data/gapminder/2007.xlsx")
)
```

Instead, let's use `map()`.

### It's the map!

![](images/clipboard-545452766.png){fig-align="right" width="98"}

Instead of typing all the paths to create the individual files, we can use the `map()` function from the package **purrr** to apply read function across multiple files:

```{r}
# Apply the function read_excel across all paths in the
# paths character vector and output the results
# as the list of tibbles called files 
files <- map(paths, readxl::read_excel)
typeof(files)
length(files)
glimpse(files)

files[[1]] # access one of the data files
# View(files) #uncomment to explore the files list in View

```

### What binds us is `list_rbind()`

Combine the list of tibbles into one large dataset with the **purrr** package function `list_rbind()`. 

```{r}
onebigfile <- list_rbind(files)
onebigfile
```

::: callout-note
Other useful functions to learn about are `list_cbind()` and `list_c()`. 
:::

But there's a big problem in that we can no longer identify the year to which the case applies.

We use `set_names(basename)` to extract the base file name with the identifying year information and attach it to the files list.


```{r}
files <- paths |> 
  set_names(basename) |> 
  map(readxl::read_excel)
```

Now we can once again use `list_rbind()` to obtain the combined data with each year identified from the basename using the `names_to` argument:

```{r}
mybigdataframe <-
  paths |>
  set_names(basename) |>
  map(readxl::read_excel) |>
  list_rbind(names_to = "year") |> # create a new variable called year with the basename
  mutate(year = parse_number(year)) # parse to remove the xlsx extension
# View(mybigdataframe)
write_csv(mybigdataframe, "gapminder.csv")
```

Use `write_csv(df, file)` to write the R data frame `df` to a quoted file name.


::: callout-note
R4DS discusses more complicated file/directory naming structures and how to deal with them using commands we have learned earlier (e.g. `separate_wider_delim`).
:::